// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Spice = require("@greenlabs/ppx-spice/src/rescript/Spice.bs.js");
var Types = require("./Types.bs.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");
var Caml_js_exceptions = require("rescript/lib/js/caml_js_exceptions.js");
var ContractInterfaceManager = require("./ContractInterfaceManager.bs.js");

var UndefinedEvent = /* @__PURE__ */Caml_exceptions.create("Converters.UndefinedEvent");

function eventStringToEvent(eventName, contractName) {
  if (eventName === "AwesomeEvent") {
    if (contractName === "MyAwesomeContract") {
      return /* MyAwesomeContractContract_AwesomeEventEvent */0;
    }
    throw {
          RE_EXN_ID: UndefinedEvent,
          _1: eventName,
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: UndefinedEvent,
        _1: eventName,
        Error: new Error()
      };
}

function convertAwesomeEventLogDescription(log) {
  var args = log.args;
  return {
          args: {
            identifier: args[0],
            awesomeAddress: args[1],
            awesomeValue: args[2]
          },
          name: log.name,
          signature: log.signature,
          topic: log.topic
        };
}

function convertAwesomeEventLog(logDescription, log, blockTimestamp) {
  var params_identifier = logDescription.args.identifier;
  var params_awesomeAddress = logDescription.args.awesomeAddress;
  var params_awesomeValue = logDescription.args.awesomeValue;
  var params = {
    identifier: params_identifier,
    awesomeAddress: params_awesomeAddress,
    awesomeValue: params_awesomeValue
  };
  var awesomeEventLog_blockNumber = log.blockNumber;
  var awesomeEventLog_blockHash = log.blockHash;
  var awesomeEventLog_srcAddress = log.address;
  var awesomeEventLog_transactionHash = log.transactionHash;
  var awesomeEventLog_transactionIndex = log.transactionIndex;
  var awesomeEventLog_logIndex = log.index;
  var awesomeEventLog = {
    params: params,
    blockNumber: awesomeEventLog_blockNumber,
    blockTimestamp: blockTimestamp,
    blockHash: awesomeEventLog_blockHash,
    srcAddress: awesomeEventLog_srcAddress,
    transactionHash: awesomeEventLog_transactionHash,
    transactionIndex: awesomeEventLog_transactionIndex,
    logIndex: awesomeEventLog_logIndex
  };
  return /* MyAwesomeContractContract_AwesomeEvent */{
          _0: awesomeEventLog
        };
}

var MyAwesomeContract = {
  convertAwesomeEventLogDescription: convertAwesomeEventLogDescription,
  convertAwesomeEventLog: convertAwesomeEventLog
};

var ParseEventErrorExn = /* @__PURE__ */Caml_exceptions.create("Converters.ParseEventErrorExn");

function parseEvent(log, blockTimestamp, contractInterfaceManager) {
  var logDescriptionResult = ContractInterfaceManager.parseLog(contractInterfaceManager, log);
  if (logDescriptionResult.TAG === /* Ok */0) {
    var logDescription = logDescriptionResult._0;
    var contractName = ContractInterfaceManager.getContractNameFromAddress(contractInterfaceManager, log.address);
    if (contractName === undefined) {
      return {
              TAG: /* Error */1,
              _0: {
                TAG: /* UnregisteredContract */1,
                _0: log.address
              }
            };
    }
    eventStringToEvent(logDescription.name, contractName);
    var $$event = convertAwesomeEventLog(convertAwesomeEventLogDescription(logDescription), log, blockTimestamp);
    return {
            TAG: /* Ok */0,
            _0: $$event
          };
  }
  var e = logDescriptionResult._0;
  var tmp;
  tmp = e.TAG === /* EthersParseError */0 ? ({
        TAG: /* ParseError */0,
        _0: e._0
      }) : ({
        TAG: /* UnregisteredContract */1,
        _0: e._0
      });
  return {
          TAG: /* Error */1,
          _0: tmp
        };
}

function decodeRawEventWith(rawEvent, decoder, variantAccessor) {
  var tmp;
  var exit = 0;
  var v;
  try {
    v = JSON.parse(rawEvent.params);
    exit = 1;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    var message = Belt_Option.getWithDefault(Belt_Option.flatMap(Caml_js_exceptions.as_js_exn(exn), (function (jsexn) {
                return jsexn.message;
              })), "No message on exn");
    tmp = Spice.error(undefined, "Failed at JSON.parse. Error: " + message + "", rawEvent.params);
  }
  if (exit === 1) {
    tmp = {
      TAG: /* Ok */0,
      _0: v
    };
  }
  return Belt_Result.map(Belt_Result.flatMap(tmp, Curry.__1(decoder)), (function (params) {
                var $$event = Curry._1(variantAccessor, {
                      params: params,
                      blockNumber: rawEvent.block_number,
                      blockTimestamp: rawEvent.block_timestamp,
                      blockHash: rawEvent.block_hash,
                      srcAddress: rawEvent.src_address,
                      transactionHash: rawEvent.transaction_hash,
                      transactionIndex: rawEvent.transaction_index,
                      logIndex: rawEvent.log_index
                    });
                return {
                        timestamp: rawEvent.block_timestamp,
                        chainId: rawEvent.chain_id,
                        blockNumber: rawEvent.block_number,
                        logIndex: rawEvent.log_index,
                        event: $$event
                      };
              }));
}

function parseRawEvent(rawEvent) {
  return Belt_Result.flatMap(Types.eventName_decode(rawEvent.event_type), (function (eventName) {
                return decodeRawEventWith(rawEvent, Types.MyAwesomeContractContract.AwesomeEventEvent.eventArgs_decode, Types.myAwesomeContractContract_AwesomeEvent);
              }));
}

exports.UndefinedEvent = UndefinedEvent;
exports.eventStringToEvent = eventStringToEvent;
exports.MyAwesomeContract = MyAwesomeContract;
exports.ParseEventErrorExn = ParseEventErrorExn;
exports.parseEvent = parseEvent;
exports.decodeRawEventWith = decodeRawEventWith;
exports.parseRawEvent = parseRawEvent;
/* Types Not a pure module */
